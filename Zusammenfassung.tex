\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fourier}
\usepackage{float}              
\usepackage{caption}  
\usepackage{adjustbox}
\usepackage{wrapfig}
\usepackage[hidelinks]{hyperref}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\captionsetup[figure]{name=Abb.}

\begin{document}

\tableofcontents

\newpage

\section{Einführung}

\subsection{Was ist ein Betriebssystem?}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item Hardware-Ressourcen verwaltet (CPU, Speicher, Festplatte …)
\item Abstraktionen für Anwendungen bereitgestellt \\
$\rightarrow$ Anwendungen müssen Hardware nicht direkt ansprechen
\end{itemize}

\subsubsection*{Hauptaufgaben}
\begin{enumerate}
\item Abstraktion
\begin{itemize}
\item Einheitliches Interface für versch. Hardware
\item Ziel: Wiederverwendung, höhere Abstraktion, einfache Nutzung
\item Herausforderung: Wie viel Hardware soll sichtbar bleiben?
\end{itemize}
\item Ressourcenverwaltung
\begin{itemize}
\item Entscheidet über Nutzung von CPU, RAM, etc.
\item Ziele: Schutz, Effizienz, Fairness
\item Herausforderung: Richtige Mechanismen \& Policies
\end{itemize}
\end{enumerate}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\vspace{20mm}
\adjustbox{valign=c}{\includegraphics[scale=0.7]{pictures/whatos.png}}
\caption{Grober Aufbau}
\end{minipage}
\end{figure}

\subsection{Zentrale Bausteine Betriebssysteme}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{pictures/bausteineos.png}
\caption{Bausteine OS}
\end{figure}

\section{Prozesse}

\subsection{Grundlagen}

\begin{itemize}
\item Prozess: laufende Instanz eines Programms mit eigenem Zustand (Register, Speicher, offene Dateien)
\item Programm: Nur statischer Code \& Daten; ein Prozess ist die dynamische Ausführung davon
\item Programm kann mehrere Prozesse gleichzeitig haben
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{pictures/erzeugungprozess.png}
\caption{Erzeugung eines Prozesses}
\end{figure}

\subsection{Prozess vs. Thread}

\begin{itemize}
\item Thread: Leichtgewichtiger Prozess, teilt sich den Adressraum mit anderen Threads im selben Prozess
\item Prozesse voneinander isoliert, Threads nicht
\end{itemize}

\subsection{Virtualisierung CPU}

\begin{itemize}
\item Ziel: Jeder Prozess glaubt, CPU gehöre nur ihm
\item Zeitliche Aufteilung (Time-Sharing) bei Einprozessor-Systemen
\item Direkte Ausführung erlaubt hohe Leistung, aber:
\begin{itemize}
\item Prozesse dürfen nicht direkt privilegierte Operationen ausführen
\item OS muss Prozesse unterbrechen können (z. B. bei Endlosschleifen oder I/O-Wartezeiten)
\end{itemize}
\end{itemize}

\subsection{Privilegien \& System Calls}

\begin{itemize}
\item 2 Betriebsmodi:
\begin{itemize}
\item User Mode: Eingeschränkter Zugriff
\item Kernel Mode: Voller Zugriff
\end{itemize}
\item System Calls: definierte Schnittstellen, um vom User-Modus in den Kernel-Modus zu wechseln (z. B. read(), write())
\item CPU führt bei  System Call Moduswechsel durch \& ruft einen System-Call-Handler im Kernel auf
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{pictures/syscallbsp.png}
\caption{Bsp. SysCall}
\end{figure}

\subsection{Multitasking \& Scheduling}

\begin{itemize}
\item Mechanismus: Context-Switch (Wechsel zwischen Prozessen)
\item Policy: Entscheidung, welcher Prozess wann läuft
\item 2 Varianten:
\begin{enumerate}
\item Kooperatives Multitasking: Prozess gibt CPU freiwillig ab (yield())
\begin{itemize}
\item Nachteil: Ein Prozess kann System blockieren
\end{itemize}
\item Präemptives Multitasking: OS erzwingt regelmäßig Kontrolle durch Timer-Interrupts\\
$\rightarrow$ Standard in modernen Systemen
\end{enumerate}
\end{itemize}

\subsection{Prozesskontext \& PCB}

\begin{itemize}
\item Beim Wechsel werden Register, Stackpointer usw. im Process Control Block (PCB) gespeichert
\item PCB enthält u. a.:
\begin{itemize}
\item Prozesszustand (running, ready, blocked)
\item Registerinhalte
\item PID, Eltern-/Kindbeziehungen
\item offene Dateien, Berechtigungen, Priorität
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{pictures/gespeicherteInfoPCB.png}
\caption{gespeicherte Infos in PCB}
\end{figure}

\subsection{Prozesszustände}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item Running: Prozess läuft auf CPU
\item Ready: wartet auf CPU
\item Blocked: Wartet auf Ereignis (I/O, Synchronisation)
\item OS verwaltet Ready-Queues \& Event-Queues
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-5mm}
\adjustbox{valign=c}{\includegraphics[scale=0.35]{pictures/pzustand.png}}
\caption{Prozesszustände}
\end{minipage}
\end{figure}

\subsection{Prozesserzeugung}

\subsubsection*{2 Hauptwege:}

\begin{enumerate}
\item Leerer neuer Prozess (z.B. posix\_spawn()/CreateProcess()):
\begin{itemize}
\item OS lädt Code, erstellt Stack, initialisiert PCB
\end{itemize}
\item Klonen bestehender Prozesse (Unix: fork() $+$ exec()):
\begin{itemize}
\item fork() $\rightarrow$ Duplikat des aktuellen Prozesses
\item exec() $\rightarrow$ ersetzt Prozessspeicher durch neues Programm
\item Klassisches Unix-Modell (Shells funktionieren so)
\end{itemize}
\end{enumerate}

\subsection{Prozessbeendigung}

\begin{itemize}
\item exit(status): Prozess endet mit Rückgabewert
\item Elternprozess ruft wait() auf, um Kindstatus abzuholen
\item Kind bleibt bis dahin als Zombie (defunct) in der Prozesstabelle
\end{itemize}

\section{Scheduling}

\subsection{Grundidee Schedulings}

\begin{itemize}
\item \textbf{Ziel:} faire, effiziente \& reaktionsschnelle Zuteilung der CPU and Prozesse 
\item \textbf{Scheduler:} entscheidet welcher Prozess als Nächstes läuft 
\item \textbf{Dispatch:} führt tatsächlichen Kontextwechsel (context switch) aus 
\item \textbf{Workload:} Menge an Jobs mit Ankunftszeit ($T_{\text{arrival}}$) \& Laufzeit ($T_{\text{run}}$)
\item \textbf{Metriken:}
\begin{itemize}
\item Durchlaufzeit (Turnaround Time): $T_{\text{turnaround}}= T_{\text{completion}} - T_{\text{arrival}}$
\item Reaktionszeit (Response Time) : $T_{\text{response}} = T_{\text{firstrun}} - T_{\text{arrival}}$
\item Wartezeit \& Overhead minimieren
\item Durchsatz, Ressourcenauslastung \& Fairness maximieren
\end{itemize}
\end{itemize}

\subsection{Wichtige Schedulingstrategien}

\begin{enumerate}
\item \textbf{FIFO/FCFS (First Come, First Serve)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item nicht präemptiv, läuft bis Ende
\item erst A, dann B \& zum Schluss C
\item einfach, aber Konvoi-Effekt $\rightarrow$ 1. langer Job blockiert weitere kurze
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=.35]{pictures/fifosche.png}}
\caption{$\Delta T_{\text{turnaround}} =(10s+20s+30s)/3 = 20s$}
\end{minipage}
\end{figure}
\item \textbf{SJF (Shortest Job First)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item nicht präemptiv, wählt kürzesten Job
\item optimal für minimale durchschnittliche Durchlaufzeit (bekannte Laufzeiten)
\item nicht geeignet, wenn Ankunftszeiten unterschiedlich oder Laufzeiten unbekannt
\item kurze Jobs vorziehen verbessert Durchlaufzeit
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-7mm}
\adjustbox{valign=c}{\includegraphics[scale=.35]{pictures/sjfsche.png}}
\caption{$Delta T_{\text{turnaround}} = (80s+10s+20s)/3 = 36,7s$}
\end{minipage}
\end{figure}
\item \textbf{STCF (Shortest Time to Completion First)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item präemptive Variante von SJF
\item wählt Job mit kürzester verbleibenden Zeit
\item bessere Reaktionszeit \& geringe mittlere Durchlaufzeit
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=.35]{pictures/stcfsche.png}}
\caption{$\Delta T_{\text{turnaround}} =(80s+(20s-10s)+(30s-10s))/3 = 36,7s$}
\end{minipage}
\end{figure}
\newpage
\item \textbf{RR (Round Robin)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item präemptiv mit Zeitquanten(/-scheiben)
\item allen Prozessen gegenüber fair, gut für interaktive Systeme
\item schlechtere Durchlaufzeiten, aber gute Reaktionszeiten
\item Zeitscheibenlänge zu kurz $\rightarrow$ viel Overhead, zu lang $\rightarrow$ schlechte Reaktionszeit
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-5mm}
\adjustbox{valign=c}{\includegraphics[scale=.4]{pictures/fifovsrr.png}}
\caption{FIFO vs RR: \\ $T_{\text{reaction}}= (0+5+10)/3=5$ ~ ~ ~ ~ ~ ~ ~ ~ $T_{\text{reaction}}=(0+1+2)/3=1$}
\end{minipage}
\end{figure}
\end{enumerate}

\subsection{Erweiterungen: Realistische Szenarien}

\textbf{I/O-Einfluss}
\begin{itemize}
\item Prozesse wechseln zw. CPU- \& I/O-Phasen
\item CPU-bound vs I/O-bound Prozesse $\rightarrow$ Scheduling muss reagieren
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.5]{pictures/oio.png}
\caption{keine Berücksichtigung von I/O}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.5]{pictures/mio.png}
\caption{mit Berücksichtigung von I/O)}
\end{minipage}
\end{figure}

\noindent
\textbf{MLFQ (Multi-Level Feedback Queue)}
\begin{itemize}
\item mehrere Priostufen mit Round Robin pro Ebene:
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{enumerate}
\item priority(A) > priority(B), A ausführen
\item priority(A) == priority(B), A \& B nach RR ausführen
\item Start von Prozess mit höchster Prio
\item nutzt Job gesamte Zeitscheibe dann runterstufen
\end{enumerate}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-10mm}
\adjustbox{valign=c}{\includegraphics[scale=.5]{pictures/prio.png}}
\caption{Prio nach Round Robin}
\end{minipage}
\end{figure}
\item interaktive Prozesse (I/O-bound) in höheren Queues $\rightarrow$ bessere Reaktionszeit
\item herabstufen von CPU-bound Prozessen
\item Probleme: Starvation \& Systemausnutzung $\rightarrow$ Lösung durch dynamische Anpassung
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.4]{pictures/cpubound.png}
\caption{CPU-bound $\rightarrow$ langlaufender Job}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.4]{pictures/iobound.png}
\caption{I/O-bound $\rightarrow$ interaktiver Prozess}
\end{minipage}
\end{figure}

\subsection{Modernes Scheduling: CFS (Complety Fair Scheduler, Linux ab 2007)}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Ziel: Jeder Prozess erhält fairen Anteil der CPU
\item Virtuelle Laufzeit (vruntime): misst tatsächliche CPU-Nutzung
\item Prozesse in Red-Black-Tree sortiert \\ $\rightarrow$ geringste vruntime zuerst
\item Zeitscheiben abhängig von: \\
\[\text{time\_slice} = \frac{\text{sched\_latency}}{\text{\#processes}}\]
mit Mindestwert $\text{min\_granularity}$
\item Prios (nice-Wert) beeinflussen Gewicht
\begin{itemize}
\item nice von -20 (hoch) bis +19 (niedrig)
\item Laufzeit wächst langsamer für hohe Prioritäten
\end{itemize}
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{0mm}
\adjustbox{valign=c}{\includegraphics[scale=.5]{pictures/vrun.png}}
\caption{Ready Queue in einem Red-Black-Tree}
\end{minipage}
\end{figure}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.3]{pictures/cfs.png}
\caption{Bespiel von CFS}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.3]{pictures/cfsprio.png}
\caption{Bespiel von CFS mit Prio}
\end{minipage}
\end{figure}

\end{document}