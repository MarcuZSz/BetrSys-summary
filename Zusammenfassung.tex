\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fourier}
\usepackage{float}              
\usepackage{caption}  
\usepackage{adjustbox}
\usepackage{wrapfig}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\captionsetup[figure]{name=Abb.}

\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!60!black}\itshape,
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  frame=single,
  breaklines=true
}

\begin{document}

\tableofcontents

\newpage

\section{Einführung}

\subsection{Was ist ein Betriebssystem?}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item Hardware-Ressourcen verwaltet (CPU, Speicher, Festplatte …)
\item Abstraktionen für Anwendungen bereitgestellt \\
$\rightarrow$ Anwendungen müssen Hardware nicht direkt ansprechen
\end{itemize}

\subsubsection*{Hauptaufgaben}
\begin{enumerate}
\item Abstraktion
\begin{itemize}
\item Einheitliches Interface für versch. Hardware
\item Ziel: Wiederverwendung, höhere Abstraktion, einfache Nutzung
\item Herausforderung: Wie viel Hardware soll sichtbar bleiben?
\end{itemize}
\item Ressourcenverwaltung
\begin{itemize}
\item Entscheidet über Nutzung von CPU, RAM, etc.
\item Ziele: Schutz, Effizienz, Fairness
\item Herausforderung: Richtige Mechanismen \& Policies
\end{itemize}
\end{enumerate}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\vspace{20mm}
\adjustbox{valign=c}{\includegraphics[scale=0.7]{pictures/whatos.png}}
\caption{Grober Aufbau}
\end{minipage}
\end{figure}

\subsection{Zentrale Bausteine Betriebssysteme}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{pictures/bausteineos.png}
\caption{Bausteine OS}
\end{figure}

\section{Prozesse}

\subsection{Grundlagen}

\begin{itemize}
\item Prozess: laufende Instanz eines Programms mit eigenem Zustand (Register, Speicher, offene Dateien)
\item Programm: Nur statischer Code \& Daten; ein Prozess ist die dynamische Ausführung davon
\item Programm kann mehrere Prozesse gleichzeitig haben
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{pictures/erzeugungprozess.png}
\caption{Erzeugung eines Prozesses}
\end{figure}

\subsection{Prozess vs. Thread}

\begin{itemize}
\item Thread: Leichtgewichtiger Prozess, teilt sich den Adressraum mit anderen Threads im selben Prozess
\item Prozesse voneinander isoliert, Threads nicht
\end{itemize}

\subsection{Virtualisierung CPU}

\begin{itemize}
\item Ziel: Jeder Prozess glaubt, CPU gehöre nur ihm
\item Zeitliche Aufteilung (Time-Sharing) bei Einprozessor-Systemen
\item Direkte Ausführung erlaubt hohe Leistung, aber:
\begin{itemize}
\item Prozesse dürfen nicht direkt privilegierte Operationen ausführen
\item OS muss Prozesse unterbrechen können (z. B. bei Endlosschleifen oder I/O-Wartezeiten)
\end{itemize}
\end{itemize}

\subsection{Privilegien \& System Calls}

\begin{itemize}
\item 2 Betriebsmodi:
\begin{itemize}
\item User Mode: Eingeschränkter Zugriff
\item Kernel Mode: Voller Zugriff
\end{itemize}
\item System Calls: definierte Schnittstellen, um vom User-Modus in den Kernel-Modus zu wechseln (z. B. read(), write())
\item CPU führt bei  System Call Moduswechsel durch \& ruft einen System-Call-Handler im Kernel auf
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{pictures/syscallbsp.png}
\caption{Bsp. SysCall}
\end{figure}

\subsection{Multitasking \& Scheduling}

\begin{itemize}
\item Mechanismus: Context-Switch (Wechsel zwischen Prozessen)
\item Policy: Entscheidung, welcher Prozess wann läuft
\item 2 Varianten:
\begin{enumerate}
\item Kooperatives Multitasking: Prozess gibt CPU freiwillig ab (yield())
\begin{itemize}
\item Nachteil: Ein Prozess kann System blockieren
\end{itemize}
\item Präemptives Multitasking: OS erzwingt regelmäßig Kontrolle durch Timer-Interrupts\\
$\rightarrow$ Standard in modernen Systemen
\end{enumerate}
\end{itemize}

\subsection{Prozesskontext \& PCB}

\begin{itemize}
\item Beim Wechsel werden Register, Stackpointer usw. im Process Control Block (PCB) gespeichert
\item PCB enthält u. a.:
\begin{itemize}
\item Prozesszustand (running, ready, blocked)
\item Registerinhalte
\item PID, Eltern-/Kindbeziehungen
\item offene Dateien, Berechtigungen, Priorität
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{pictures/gespeicherteInfoPCB.png}
\caption{gespeicherte Infos in PCB}
\end{figure}

\subsection{Prozesszustände}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item Running: Prozess läuft auf CPU
\item Ready: wartet auf CPU
\item Blocked: Wartet auf Ereignis (I/O, Synchronisation)
\item OS verwaltet Ready-Queues \& Event-Queues
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{-5mm}
\adjustbox{valign=c}{\includegraphics[scale=0.35]{pictures/pzustand.png}}
\caption{Prozesszustände}
\end{minipage}
\end{figure}

\subsection{Prozesserzeugung}

\subsubsection*{2 Hauptwege:}

\begin{enumerate}
\item Leerer neuer Prozess (z.B. \texttt{posix\_spawn(})/\texttt{CreateProcess()}):
\begin{itemize}
\item OS lädt Code, erstellt Stack, initialisiert PCB
\end{itemize}
\item Klonen bestehender Prozesse (Unix: \texttt{fork()} $+$ \texttt{exec()}):
\begin{itemize}
\item \texttt{fork()} $\rightarrow$ Duplikat des aktuellen Prozesses
\item \texttt{exec()} $\rightarrow$ ersetzt Prozessspeicher durch neues Programm
\item Klassisches Unix-Modell (Shells funktionieren so)
\end{itemize}
\end{enumerate}

\subsection{Prozessbeendigung}

\begin{itemize}
\item exit(status): Prozess endet mit Rückgabewert
\item Elternprozess ruft wait() auf, um Kindstatus abzuholen
\item Kind bleibt bis dahin als Zombie (defunct) in der Prozesstabelle
\end{itemize}

\section{Scheduling}

\subsection{Grundidee Schedulings}

\begin{itemize}
\item \textbf{Ziel:} faire, effiziente \& reaktionsschnelle Zuteilung der CPU and Prozesse 
\item \textbf{Scheduler:} entscheidet welcher Prozess als Nächstes läuft 
\item \textbf{Dispatch:} führt tatsächlichen Kontextwechsel (context switch) aus 
\item \textbf{Workload:} Menge an Jobs mit Ankunftszeit ($T_{\text{arrival}}$) \& Laufzeit ($T_{\text{run}}$)
\item \textbf{Metriken:}
\begin{itemize}
\item Durchlaufzeit (Turnaround Time): $T_{\text{turnaround}}= T_{\text{completion}} - T_{\text{arrival}}$
\item Reaktionszeit (Response Time) : $T_{\text{response}} = T_{\text{firstrun}} - T_{\text{arrival}}$
\item Wartezeit \& Overhead minimieren
\item Durchsatz, Ressourcenauslastung \& Fairness maximieren
\end{itemize}
\end{itemize}

\subsection{Wichtige Schedulingstrategien}

\begin{enumerate}
\item \textbf{FIFO/FCFS (First Come, First Serve)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item nicht präemptiv, läuft bis Ende
\item erst A, dann B \& zum Schluss C
\item einfach, aber Konvoi-Effekt $\rightarrow$ 1. langer Job blockiert weitere kurze
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=.35]{pictures/fifosche.png}}
\caption{$\Delta T_{\text{turnaround}} =(10s+20s+30s)/3 = 20s$}
\end{minipage}
\end{figure}
\item \textbf{SJF (Shortest Job First)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item nicht präemptiv, wählt kürzesten Job
\item optimal für minimale durchschnittliche Durchlaufzeit (bekannte Laufzeiten)
\item nicht geeignet, wenn Ankunftszeiten unterschiedlich oder Laufzeiten unbekannt
\item kurze Jobs vorziehen verbessert Durchlaufzeit
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-7mm}
\adjustbox{valign=c}{\includegraphics[scale=.35]{pictures/sjfsche.png}}
\caption{$\Delta T_{\text{turnaround}} = (80s+10s+20s)/3 = 36,7s$}
\end{minipage}
\end{figure}
\item \textbf{STCF (Shortest Time to Completion First)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item präemptive Variante von SJF
\item wählt Job mit kürzester verbleibenden Zeit
\item bessere Reaktionszeit \& geringe mittlere Durchlaufzeit
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=.35]{pictures/stcfsche.png}}
\caption{$\Delta T_{\text{turnaround}} =(80s+(20s-10s)+(30s-10s))/3 = 36,7s$}
\end{minipage}
\end{figure}
\newpage
\item \textbf{RR (Round Robin)}
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item präemptiv mit Zeitquanten(/-scheiben)
\item allen Prozessen gegenüber fair, gut für interaktive Systeme
\item schlechtere Durchlaufzeiten, aber gute Reaktionszeiten
\item Zeitscheibenlänge zu kurz $\rightarrow$ viel Overhead, zu lang $\rightarrow$ schlechte Reaktionszeit
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-5mm}
\adjustbox{valign=c}{\includegraphics[scale=.4]{pictures/fifovsrr.png}}
\caption{FIFO vs RR: \\ $T_{\text{reaction}}= (0+5+10)/3=5$ ~ ~ ~ ~ ~ ~ ~ ~ $T_{\text{reaction}}=(0+1+2)/3=1$}
\end{minipage}
\end{figure}
\end{enumerate}

\subsection{Erweiterungen: Realistische Szenarien}

\textbf{I/O-Einfluss}
\begin{itemize}
\item Prozesse wechseln zw. CPU- \& I/O-Phasen
\item CPU-bound vs I/O-bound Prozesse $\rightarrow$ Scheduling muss reagieren
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.5]{pictures/oio.png}
\caption{keine Berücksichtigung von I/O}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.5]{pictures/mio.png}
\caption{mit Berücksichtigung von I/O}
\end{minipage}
\end{figure}

\noindent
\textbf{MLFQ (Multi-Level Feedback Queue)}
\begin{itemize}
\item mehrere Priostufen mit Round Robin pro Ebene:
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{enumerate}
\item priority(A) > priority(B), A ausführen
\item priority(A) == priority(B), A \& B nach RR ausführen
\item Start von Prozess mit höchster Prio
\item nutzt Job gesamte Zeitscheibe dann runterstufen
\end{enumerate}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-10mm}
\adjustbox{valign=c}{\includegraphics[scale=.5]{pictures/prio.png}}
\caption{Prio nach Round Robin}
\end{minipage}
\end{figure}
\item interaktive Prozesse (I/O-bound) in höheren Queues $\rightarrow$ bessere Reaktionszeit
\item herabstufen von CPU-bound Prozessen
\item Probleme: Starvation \& Systemausnutzung $\rightarrow$ Lösung durch dynamische Anpassung
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.4]{pictures/cpubound.png}
\caption{CPU-bound $\rightarrow$ langlaufender Job}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.4]{pictures/iobound.png}
\caption{I/O-bound $\rightarrow$ interaktiver Prozess}
\end{minipage}
\end{figure}

\subsection{Modernes Scheduling: CFS (Complety Fair Scheduler, Linux ab 2007)}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Ziel: Jeder Prozess erhält fairen Anteil der CPU
\item Virtuelle Laufzeit (vruntime): misst tatsächliche CPU-Nutzung
\item Prozesse in Red-Black-Tree sortiert \\ $\rightarrow$ geringste vruntime zuerst
\item Zeitscheiben abhängig von: \\
\[\text{time\_slice} = \frac{\text{sched\_latency}}{\text{\#processes}}\]
mit Mindestwert $\text{min\_granularity}$
\item Prios (nice-Wert) beeinflussen Gewicht
\begin{itemize}
\item nice von -20 (hoch) bis +19 (niedrig)
\item Laufzeit wächst langsamer für hohe Prioritäten
\end{itemize}
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{15mm}
\adjustbox{valign=c}{\includegraphics[scale=.5]{pictures/vrun.png}}
\caption{Ready Queue in einem Red-Black-Tree}
\end{minipage}
\end{figure}

Prozess k mit Gewicht:
\[\text{time\_slice}_k = \frac{\text{weight}_k}{\sum_{i=0}^{n-1}\text{weight}_i} \cdot \text{sched\_latency}\]
Aktualisierung virtueller Laufzeit:
\[\Delta \text{vruntime}_k = \frac{\text{weight}_0}{\text{weight}_k} \cdot \text{vruntime}_k\]

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.3]{pictures/cfs.png}
\caption{Bespiel von CFS}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.3]{pictures/cfsprio.png}
\caption{Bespiel von CFS mit Prio}
\end{minipage}
\end{figure}

\section{Speichervirtualisierung}

\subsection{Grundidee der Virtualisierung}

\begin{itemize}
\item Ziel: Prozesse sollen eigene, isolierte Adressräume haben
\item Mechanismen:
\begin{itemize}
\item virtuelle CPU: Context Switch, Scheduling
\item virtueller RAM: Adressübersetzung, Paging, Swapping
\end{itemize}
\item Policies: Scheduling (CPU), Seitenersetzung (RAM)
\end{itemize}

\subsection{Speicherorganisation in Prozessen}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Addressraum}
\begin{itemize}
\item Jeder Prozess hat eine Reihe von Adressen, die auf
Bytes abgebildet werden
\item statisch: Code, globale Variablen
\item dynamisch: Stack (LIFO), Heap (dynamische Alloc)
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-15mm}
\adjustbox{valign=c}{\includegraphics[scale=.4]{pictures/adraum.png}}
\caption{Addressraum}
\end{minipage}
\end{figure}

\noindent
\textbf{Stack}
\begin{itemize}
\item verwaltet lokale Variablen \& Funktionsaufrufe (Stack Frames)
\item Rekursion erzeugt neue Frames
\item Alloc/Dealloc sehr effizient (nur Stackpointer-Bewegung)
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Heap}
\begin{itemize}
\item flexible Speicherverwaltung mit \texttt{malloc()} \& \texttt{free()}
\item Probleme: Fragmentierung
\begin{itemize}
\item intern: Block größer als benötigt
\item extern: freie Blöcke zu klein verteilt
\end{itemize}
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{5mm}
\adjustbox{valign=c}{\includegraphics[scale=.4]{pictures/haf.png}}
\caption{Heap mit \texttt{free} \& \texttt{alloc}}
\end{minipage}
\end{figure}

\subsection{Speicherverwaltungsstrategien}

\textbf{Free List}
\begin{itemize}
\item freie Blöcke in einer Liste gespeichert
\item First Fit: Beginnend vom Kopf der Liste, finde den ersten genügend großen Block \& teile ihn auf
\item Best Fit: Finde den kleinsten, gerade noch passenden Block für die Alloc
\item Worst Fit: Wenn kein passender Block in der Liste existiert, finde den größten Block \& teile ihn auf (um
kleine Restblöcke zu verhindern)
\item Next Fit: Wie First Fit, aber beginne jeweils hinter dem zuletzt aufgeteilten Block
\item Coalescing = Nachbarblöcke zsmführen
\end{itemize}

\noindent
\textbf{Buddy Allocator}
\begin{itemize}
\item Speicher in 2er-Potenzen geteilt
\item vereinfacht zsmführen (\glqq Buddy\grqq -Blöcke, XOR)
\item Nachteil: feste Blockgrößen $\rightarrow$ interne Fragmentierung
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.325]{pictures/bulloc.png}
\caption{Bsp zum Buddy Allocator}
\end{figure}

\subsection{Speicherzugriff}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Variablen je nach Typ}
\begin{itemize}
\item Code: ausführbarer Speicher
\item Statische Daten: global
\item Stack: lokale Variablen
\item Heap: dynamic allocated data
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.6\textwidth}
\begin{lstlisting}
int x;

int main(int argc, char *argv[]) {
	int y;
	int *z;
	z = malloc(sizeof(int));
}
\end{lstlisting}
\end{minipage}
\end{figure}

\subsection{Virtualisierung des Speichers}

Ziel: Mehrere Prozesse gleichzeitig ohne Konflikte

\begin{enumerate}
\item Zeitliche Aufteilung (time sharing)
\begin{itemize}
\item Prozesse nacheinander im RAM, Rest auf Disk
\item extrem langsamer Disk-I/O bei jedem Kontaktwechsel
\begin{figure}[H]
\begin{minipage}[t]{.15\textwidth}
\centering
\includegraphics[scale=.15]{pictures/time_share_1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.2\textwidth}
\centering
\includegraphics[scale=.15]{pictures/time_share_2.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.15\textwidth}
\centering
\includegraphics[scale=.15]{pictures/time_share_3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.15\textwidth}
\centering
\includegraphics[scale=.15]{pictures/time_share_4.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.15\textwidth}
\centering
\includegraphics[scale=.15]{pictures/time_share_5.png}
\end{minipage}
\caption{Beispiel zum Time-Share-Speicher}
\end{figure}
\end{itemize}
\item Statische Verschiebung
\begin{itemize}
\item OS schreibt Programm beim Laden um (Adressen anpassen)
\item kein Schutz, keine flexible Umschichtung
\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/speicherlayout.png}
\caption{Layout im Speicher}
\end{figure}
\end{itemize}
\item Dynamische Verschiebung (Basisregister)
\begin{itemize}
\item Hardware (MMU) addiert bei jedem Zugriff einen Offset (Basisregister)
\item jeder Prozess bekommt eigenes Basisregister $\rightarrow$ Schutz möglich
\item kein Limit $\rightarrow$ Prozess kann in Speicher anderer schreiben
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.25]{pictures/mmu.png}
\caption{MMU ändert Prozessadresse dynamisch}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.25]{pictures/basisregister.png}
\caption{Implementierung Basisregister}
\end{minipage}
\end{figure}
\end{itemize}
\item Base + Bounds
\begin{itemize}
\item zusätzliches Bounds-Register begrenzt Adressraumgröße
\item Schutz bei Überschreitung $\rightarrow$ Interrupt
\item schnell, einfach, geschützt
\item jeder Prozess braucht zusammenhängenden Speicher
\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/base+bounds.png}
\caption{Base+Bounds Implementierung}
\end{figure}
\end{itemize}
\item Segmentierung
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Adressraum in logische Segmente (Code, Stack, Heap) geteilt
\item jedes Segment hat eigenes Base+Bounds \& Schutzrechte
\item getrenntes Wachsen, selektives Sharing, Schutz
\item externe Fragmentierung, Speicher evtl. nicht contiguous
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-5mm}
\includegraphics[scale=.5]{pictures/segimp.png}
\caption{Segmentierung Implementierung}
\end{minipage}
\end{figure}
\end{enumerate}

\end{document}